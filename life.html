<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Life</title>
</head>
<body>
<h1>Life</h1>
<div id="status" aria-atomic="true" aria-live="polite"></div>

<fieldset id="parameters">
<legend><h2>Parameters</h2></legend>
<label>Grid size: <input type="number" id="size" value="10" min="3" max="100" accesskey="s"></label>
<br><label>Initially living: <input type="number" id="seed" value="0" min="0" max="1" step="0.01" accesskey="l"></label>
<br><label>Panning model: <input type="text" id="panningModel" value="HRTF" accesskey="p"></label>
</fieldset>

<fieldset id="control">
<legend><h2>Control</h2></legend>
<button id="initialize" accesskey="g">Initialize</button>
<button id="test-seed" accesskey="p">Insert test seed</button>
<br><label>Generation interval: <input type="number" id="interval" value="0.1" min="0.005" max="1.0" step="0.005" accesskey="i"></label>
<button id="run" aria-pressed="false" accesskey="r">run</button>
<button id="clear" accesskey="c">Clear</button>
<br><button id="alive">Alive counts</button>
<button id="living">Living cells</button>

<!--
<div>
<label>Test mode: <input type="checkbox" id="testMode" accesskey="t"></label>
<label>Set: <input type="text" id="coordinates" value="0 0" accesskey="c"></label>
<button id="step">Step</button>
<span role="application">
<button id="explore" accesskey="e">Explore</button>
</span>
</div>
-->
</fieldset>

<div role="application" id="grid"></div>

<script type="module">
import {Life, statusMessage} from "./life.js";
statusMessage("Ready.");

const parameters = $("#parameters");
const run = $("#run");
const alive = $("#alive");
const living = $("#living");
const initialize = $("#initialize");

let _alive = _valueOf(alive), _generation = 0, _interval = _valueOf("interval");
let life, display;


$("#grid").addEventListener("keydown", gridKeyboardHandler);
$("#grid").addEventListener("focus", () => {
unfocusAll();
focus(display.buffer[0]);
});


initialize.addEventListener("click", () => {
if (life) life.stop();
_generation = 0;
[life, display] =   init();
$("#grid").innerHTML = "";
$("#grid").appendChild(display.grid);
}); // init

$("#test-seed").addEventListener("click", () => {
if (not(life)) return;
life.setBuffer(39, 47, 48, 58, 59);
updateDisplay(display, life.current.buffer);
});

$("#clear").addEventListener("click", () => {
if (not(life)) return;
life.clear();
updateDisplay(display, life.current.buffer);
});


function init () {
const life = new Life(_valueOf("size"), _valueOf("seed"), _valueOf("panningModel"));
const display = createDisplay(_valueOf("size"));

life.displayCallback = (grid) => {
updateDisplay(display, grid.buffer);
};

life.stopCallback = (alive, generation) => {
_alive = alive;
_generation = generation;
run.setAttribute("aria-pressed", "false");
report("stopped");
};

display.grid.addEventListener("change", e => {
const checkbox = e.target;
if (checkbox instanceof HTMLInputElement && display?.checkboxMap.has(checkbox)) {
const index = display.checkboxMap.get(checkbox);
life.current.buffer[index] = checkbox.checked? 1 : 0;
} else {
alert("invalid checkbox map!");
throw new Error("invalid checkbox map!");
} // if
}); // checkbox listener

return [life, display];
} // init

run.addEventListener("click", e => {
let state = e.target.getAttribute("aria-pressed") === "true";
state = not(state);
e.target.setAttribute("aria-pressed", state? "true" : "false");
statusMessage(`Starting: interval = ${_valueOf("interval")}`);

if (state) life.start(_valueOf("interval"), _generation);
else life.stop();
}); // click handler

$("#interval").addEventListener("change", e => {
life.generationInterval = _valueOf("interval");
});

alive .addEventListener("click", () => report());
living.addEventListener("click", () => reportLivingCells());


function gridKeyboardHandler (e) {
if (not(e.target instanceof HTMLInputElement)) return;
const key = e.key;
const buffer = display.buffer;
const size = _valueOf("size");
const cellCount = size*size;
const element = getFocus();
const index = display.checkboxMap.get(element);


const commands = {
"ArrowUp": function previousRow() {
if (index >= size) focus(buffer[index-size]);
},
"ArrowDown": function nextRow () {
if (index+size < cellCount) focus(buffer[index+size]);
},

"ArrowLeft": function previous () {
if (e.altKey && index%size > 0) focus(previousCell(index));
else if (e.ctrlKey) focus(previousLiveCell(index));
else focus(previousCell(index));
},
"ArrowRight": function next () {
if (e.altKey && index%size < size-1) focus(nextCell(index));
else if (e.ctrlKey) focus(nextLiveCell(index));
else focus(nextCell(index));
},

"Enter": function () {
if (e.ctrlKey) life.sonifyPosition(index);
}, // sonifyPosition
}; // commands

if (commands[key] instanceof Function) {
e.preventDefault();
commands[key]();
} // if


function nextCell (start) {return start<buffer.length-1? buffer[start+1] : buffer[start];}
function nextLiveCell (start) {
const cell = buffer.find((x,i) => i>start && buffer[i].checked);
return cell? cell : start;
} // nextLiveCell

function previousCell (start) {return start>0? buffer[start-1] : buffer[start];}
function previousLiveCell (start) {
const cell = buffer.reverse.find((x,i) => i>start && buffer[i].checked);
return cell? cell : start;
} // previousLiveCell
} // grid keyboard handler

function unfocusAll () {display.grid.querySelectorAll("[tabindex='0']").forEach(x => x.tabIndex = -1);}
function getFocus () {return $("[tabindex='0']", display.grid);}

function focus (cell, announceCoordinates = true) {
const index = display.checkboxMap.get(cell);
const size = life.size;
const r = Math.floor(index/size) + 1;
const c = index % size + 1;

unfocusAll();
cell.tabIndex = 0;
cell.focus();

if (announceCoordinates) setTimeout(() => statusMessage(`${r}, ${c}`), 700);
} // focus

/// test mode

/*$("#testMode").addEventListener("change", e => life.enableTestMode(e.target.checked));

$("#coordinates").addEventListener("click", e => {
const values = e.target.value.split(" ")
.map(pair => pair.split(","))
console.debug(`values: ${JSON.stringify(values)}`);

values.forEach( pair => life.setCell(Number(pair[0]), Number(pair[1])));
}); // coordinates


$("#step").addEventListener("click", () => life.step());
$("#clear").addEventListener("click", () => life.clear());

$("#coordinates").addEventListener("keydown", e => {
switch (e.key) {
case "Enter": e.target.dispatchEvent(new CustomEvent("click"));
break;
default: return;
} // switch
e.preventDefault();
}); // send click

$("#explore").addEventListener("keydown", exploreHandler);

let coordinates = [0,0];
function exploreHandler (e) {
if (life.testMode) {
let [r,c] = coordinates;
const size = life.size;

switch (e.key) {
case "ArrowLeft": c -= 1; break;
case "ArrowRight": c += 1; break;
case "ArrowDown": r -= 1; break;
case "ArrowUp": r += 1; break;
default: return;
} // switch

e.preventDefault();
//r = clamp(r, 0, size-1, "row out of bounds");
//c = clamp(c, 0, size-1, "column out of bounds");
life.clear();
life.setCell(r, c);
life.startAudio();
life.sonify();
setTimeout(() => life.stopAudio(), 300);
coordinates = [r,c];

function clamp (value, min, max, message) {
if (value >= min && value <= max) return value;
if (value > max) value = max;
else value = min;
statusMessage(message);
return value;
} // clamp
} // if
} // exploreGridHandler
*/


function getCoordinates (text) {
const values = text.split(/,*[ ]+/);
return [Number(values[0]), Number(values[1])];
} // getCoordinates




function report (stopped) {
const sameCells = (life.alive.current === life.alive.next && compareGrids(life.current, life.next))? 
"(same cells)" : "";

if (stopped) {
statusMessage(`<p>
stopped at generation ${life.generation}
with ${life.alive.current} living cells and ${life.alive.next} alive in next generation ${sameCells}.
</p>`);
} else {
statusMessage(`${life.generation}: ${life.alive.current}, ${life.alive.next} ${sameCells}`);
} // if
} // report

function reportLivingCells () {
statusMessage(`current: ${livingCells(life.current).join(", ")}\n
next: ${livingCells(life.next).join(", ")}
`);
} // reportLivingCells

function livingCells (g) {
return Array.from(g.buffer.entries())
.filter(x => x[1] !== 0)
.map(x => x[0]);
} // livingCells

function compareGrids (g1, g2) {
return g1.buffer.every((x,i) => g2.buffer[i] === x);
} // compareGrids


function createDisplay (size) {
const table = document.createElement("table");
const checkboxes = [];
const checkboxMap = new Map();
let index = 0;

for (let r=0; r<size; r++) {
const row = document.createElement("tr");

for (let c=0; c<size; c++) {
const cell = document.createElement("td");

const checkbox = document.createElement("input");
checkboxes[index] = checkbox;
checkboxMap.set(checkbox, index);
index += 1;

checkbox.type = "checkbox";
checkbox.tabIndex = -1;
cell.appendChild(checkbox);
row.appendChild(cell);
} // loop over columns

table.appendChild(row);
} // loop over rows

checkboxes[0].tabIndex = 0;
return {grid: table, buffer: checkboxes, checkboxMap};
} // createDisplay

function updateDisplay (display, buffer) {
for (let i=0; i<buffer.length; i++) {
display.buffer[i].checked = (buffer[i] === 0? false : true);
} // for

const checkCount = display.buffer.reduce((a, x) => x.checked? a += 1 : a += 0, 0);
const aliveCount = buffer.reduce((a, x) => a += x, 0);
alert(`checked: ${checkCount}, alive: ${aliveCount}`);

} // updateDisplay



function _valueOf (element, context) {
element = typeof(element) === "string"? $(`#${element}`, context) : element;
return element.hasAttribute("value")? _get(element.value)
:  (element.hasAttribute("data-value")? _get(element.dataset.value) : "");

function _get(x) {
return x? (Number(x) || x)
: "";
} // _get
} // _valueOf


function $ (selector, context = document) {
return context.querySelector(selector);
} // $

function not (x) {return !Boolean(x);}

</script>

</body>
</html>
